<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Geometry Dash Clone + Editor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, sans-serif;
      color: white;
      user-select: none;
      overflow: hidden;
    }

    #container { position: relative; }
    canvas { border-radius: 8px; display: block; }

    /* ---------- MENU ---------- */
    #menuPanel {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      background: radial-gradient(circle at top, rgba(0,0,0,0.3), #000);
      z-index: 10;
    }

    #menuPanel h1 {
      font-size: 34px;
      text-shadow: 0 0 12px #0099ff;
      margin-bottom: 8px;
    }

    .levelBtn {
      padding: 8px 16px;
      width: 260px;
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(10,25,60,0.9);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 15px;
      transition: 0.15s;
    }
    .levelBtn:hover { filter: brightness(1.22); }

    .menuBtn {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #00e1ff, #0066ff);
      color: white;
      font-weight: 600;
      font-size: 14px;
      margin-top: 4px;
      transition: 0.15s;
    }
    .menuBtn:hover { filter: brightness(1.15); transform: translateY(-1px); }

    /* ---------- LEVEL COMPLETE UI ---------- */
    #levelCompleteScreen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(3px);
      z-index: 20;
      text-align: center;
    }

    #completeTitle {
      font-size: 48px;
      font-weight: 800;
      color: #00ff66;
      text-shadow: 0 0 12px #00ff66, 0 0 24px #00aa44;
      margin-bottom: 20px;
      animation: glow 1.7s infinite alternate ease-in-out;
    }

    @keyframes glow {
      from { text-shadow: 0 0 8px #00ff66; }
      to   { text-shadow: 0 0 22px #00ff66; }
    }

    .barStripe {
      width: 420px;
      height: 34px;
      margin: 6px 0;
      background: linear-gradient(90deg,
        rgba(0,255,100,0.7),
        rgba(0,255,100,0.25)
      );
      border-radius: 6px;
      transform: translateX(-600px);
      animation: slideIn 0.9s forwards ease-out;
    }

    @keyframes slideIn {
      to { transform: translateX(0); }
    }

    .completeBtn {
      margin-top: 18px;
      padding: 9px 24px;
      background: #00c04b;
      border: none;
      font-weight: 600;
      border-radius: 999px;
      cursor: pointer;
      font-size: 16px;
      color: #000;
      transition: 0.15s;
    }

    .completeBtn:hover {
      filter: brightness(1.15);
      transform: translateY(-2px);
    }

    /* ---------- EDITOR HELP ---------- */
    #editorHelp {
      position: absolute;
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: 0.9;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="game" width="900" height="500"></canvas>

  <!-- LEVEL COMPLETE UI -->
  <div id="levelCompleteScreen">
    <div id="completeTitle">LEVEL COMPLETE!</div>
    <div class="barStripe"></div>
    <div class="barStripe"></div>
    <div class="barStripe"></div>
    <button id="btnNext" class="completeBtn">Next Level</button>
    <button id="btnRetry" class="completeBtn">Retry</button>
    <button id="btnMenu" class="completeBtn">Menu</button>
  </div>

  <!-- MENU -->
  <div id="menuPanel">
    <h1>Geometry Dash Clone</h1>
    <button class="levelBtn" data-level="0">
      <span>Stereo Lite</span><span>Normal</span>
    </button>
    <button class="levelBtn" data-level="1">
      <span>Harder Dash</span><span>Hard</span>
    </button>
    <button class="levelBtn" data-level="2">
      <span>Insane Run</span><span>Insane</span>
    </button>
    <button id="btnEditor" class="menuBtn">Level Editor</button>
  </div>

  <div id="editorHelp">
    Editor: A/D = move • 1=Spike 2=Pad 3=Gravity 4=Speed • Left Click=place • Right Click=delete • E=Play Custom • Esc=Menu
  </div>
</div>

<script>
/* =========================================================
   CANVAS & DOM
========================================================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const completeUI = document.getElementById("levelCompleteScreen");
const btnNext = document.getElementById("btnNext");
const btnRetry = document.getElementById("btnRetry");
const btnMenu = document.getElementById("btnMenu");
const menuPanel = document.getElementById("menuPanel");
const btnEditor = document.getElementById("btnEditor");
const editorHelp = document.getElementById("editorHelp");

const W = canvas.width;
const H = canvas.height;

const GROUND_Y = 390;
const CEIL_Y = 110;

/* =========================================================
   GAME STATE
========================================================= */
let scene = "menu"; // "menu", "playing", "dead", "complete", "editor"
let currentLevel = 0;
let isCustomLevel = false;

const player = {
  x: W * 0.2,
  y: GROUND_Y - 20,
  size: 40,
  velY: 0,
  rotation: 0,
  onGround: true,
  isDead: false,
};

let gravityDir = 1;
let gravityVal = 0.7;
let baseSpeed = 6;
let currentSpeedMult = 1;
let cameraX = 0;
let attempts = 0;

let currentObjects = [];
let finishPortalX = 0;
let completeShown = false;

/* Approximate pixels per second = speed * 60 fps */
const PIXELS_PER_SECOND = 6 * 60;

/* =========================================================
   LEVEL DEFINITIONS
========================================================= */
const levels = [
  { id: 0, name: "Stereo Lite",  targetSeconds: 25 },
  { id: 1, name: "Harder Dash",  targetSeconds: 35 },
  { id: 2, name: "Insane Run",   targetSeconds: 40 },
];

/* =========================================================
   EDITOR STATE
========================================================= */
const editor = {
  objects: [],
  camX: 0,
  grid: 50,
  selectedType: "spike", // spike, pad, gravityPortal, speedPortal
  speedModeIndex: 0,
  speedModes: [0.8, 1.0, 1.4, 1.8]
};

/* =========================================================
   INPUT
========================================================= */
let jumpQueued = false;

window.addEventListener("keydown", (e) => {
  if (["Space", "ArrowUp"].includes(e.code)) {
    if (scene === "playing") {
      e.preventDefault();
      jumpQueued = true;
    }
  }

  if (e.code === "Escape") {
    if (scene === "playing" || scene === "dead" || scene === "complete") {
      goMenu();
    } else if (scene === "editor") {
      goMenu();
    }
  }

  if (scene === "editor") {
    if (e.key === "a" || e.key === "A") editor.camX -= 40;
    if (e.key === "d" || e.key === "D") editor.camX += 40;
    if (e.key === "1") editor.selectedType = "spike";
    if (e.key === "2") editor.selectedType = "pad";
    if (e.key === "3") editor.selectedType = "gravityPortal";
    if (e.key === "4") editor.selectedType = "speedPortal";
    if (e.key === "e" || e.key === "E") {
      startCustomLevel();
    }
  }
});

canvas.addEventListener("mousedown", (e) => {
  if (scene === "playing") {
    jumpQueued = true;
    return;
  }

  if (scene === "editor") {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldX = editor.camX + mx;
    const snapped = Math.round(worldX / editor.grid) * editor.grid;

    if (e.button === 2) {
      // right click = delete
      deleteEditorObject(snapped);
    } else if (e.button === 0) {
      placeEditorObject(snapped);
    }
  }
});

canvas.addEventListener("contextmenu", (e) => {
  if (scene === "editor") e.preventDefault();
});

/* =========================================================
   MENU BUTTONS
========================================================= */
document.querySelectorAll(".levelBtn").forEach(btn => {
  btn.onclick = () => {
    const id = parseInt(btn.dataset.level);
    startLevel(id);
  };
});

btnEditor.onclick = () => {
  scene = "editor";
  menuPanel.style.display = "none";
  editorHelp.style.display = "block";
};

btnRetry.onclick = () => {
  if (isCustomLevel) {
    startCustomLevel();
  } else {
    startLevel(currentLevel);
  }
};

btnMenu.onclick = () => goMenu();

btnNext.onclick = () => {
  if (isCustomLevel) {
    goMenu();
  } else {
    const next = currentLevel + 1;
    if (next < levels.length) startLevel(next);
    else goMenu();
  }
};

/* =========================================================
   EDITOR FUNCTIONS
========================================================= */
function placeEditorObject(x) {
  const exists = editor.objects.find(o => Math.abs(o.x - x) < 10);
  if (exists) return; // don't double stack

  if (editor.selectedType === "spike") {
    editor.objects.push({ type: "spike", x, w: 50, h: 60 });
  } else if (editor.selectedType === "pad") {
    editor.objects.push({ type: "pad", x, w: 60, h: 18 });
  } else if (editor.selectedType === "gravityPortal") {
    editor.objects.push({ type: "gravityPortal", x, w: 40, h: 80 });
  } else if (editor.selectedType === "speedPortal") {
    editor.speedModeIndex = (editor.speedModeIndex + 1) % editor.speedModes.length;
    const mult = editor.speedModes[editor.speedModeIndex];
    editor.objects.push({ type: "speedPortal", x, w: 40, h: 80, speedMult: mult });
  }
}

function deleteEditorObject(x) {
  editor.objects = editor.objects.filter(o => Math.abs(o.x - x) >= 25);
}

function startCustomLevel() {
  if (editor.objects.length === 0) return;
  isCustomLevel = true;
  completeShown = false;
  completeUI.style.display = "none";
  editorHelp.style.display = "none";

  currentObjects = editor.objects.map(o => ({ ...o, triggered: false }));
  // finish portal after last object
  const maxX = Math.max(...currentObjects.map(o => o.x));
  finishPortalX = maxX + 250;

  gravityDir = 1;
  currentSpeedMult = 1;
  baseSpeed = 6;
  cameraX = 0;

  player.x = W * 0.2;
  player.y = GROUND_Y - player.size / 2;
  player.velY = 0;
  player.rotation = 0;
  player.onGround = true;

  scene = "playing";
}

/* =========================================================
   LEVEL HELPERS
========================================================= */
function addSpike(x) {
  currentObjects.push({ type: "spike", x, w: 50, h: 60 });
}
function addPad(x) {
  currentObjects.push({ type: "pad", x, w: 60, h: 18 });
}
function addGravityPortal(x) {
  currentObjects.push({ type: "gravityPortal", x, w: 40, h: 80 });
}
function addSpeedPortal(x, mult) {
  currentObjects.push({ type: "speedPortal", x, w: 40, h: 80, speedMult: mult });
}

/* Build a random-ish pattern until we reach target distance */
function buildLevelPattern(targetSeconds, difficulty) {
  currentObjects = [];
  const targetDistance = PIXELS_PER_SECOND * targetSeconds;
  let x = 600;
  let lastPattern = -1;

  while (x < targetDistance - 400) {
    // choose pattern 0–4, not same as last
    let pattern;
    do {
      pattern = Math.floor(Math.random() * 5);
    } while (pattern === lastPattern);
    lastPattern = pattern;

    const gapBase = difficulty === "easy" ? 260 : difficulty === "hard" ? 220 : 200;

    if (pattern === 0) {
      // Single spike
      addSpike(x);
      x += gapBase + 40;
    } else if (pattern === 1) {
      // Double spike
      addSpike(x);
      addSpike(x + 60);
      x += gapBase + 80;
    } else if (pattern === 2) {
      // Pad then spike
      addPad(x - 60);
      addSpike(x + 40);
      x += gapBase + 80;
    } else if (pattern === 3) {
      // Triple spike (for harder levels)
      if (difficulty !== "easy") {
        addSpike(x);
        addSpike(x + 55);
        addSpike(x + 110);
        x += gapBase + 80;
      } else {
        addSpike(x);
        x += gapBase + 100;
      }
    } else if (pattern === 4) {
      // Portals (gravity + speed) combo
      if (difficulty !== "easy") {
        addGravityPortal(x);
        x += 200;
        const mult = difficulty === "hard" ? 1.2 : 1.4;
        addSpeedPortal(x, mult);
        x += gapBase + 120;
      } else {
        x += gapBase + 120;
      }
    }
  }

  finishPortalX = targetDistance;
}

/* =========================================================
   LEVEL START / MENU
========================================================= */
function startLevel(id) {
  isCustomLevel = false;
  currentLevel = id;
  completeShown = false;
  completeUI.style.display = "none";
  menuPanel.style.display = "none";
  editorHelp.style.display = "none";

  const lvl = levels[id];
  let diff = "easy";
  if (id === 1) diff = "hard";
  if (id === 2) diff = "insane";

  buildLevelPattern(lvl.targetSeconds, diff);

  // reset
  gravityDir = 1;
  currentSpeedMult = 1;
  baseSpeed = 6;
  cameraX = 0;

  player.x = W * 0.2;
  player.y = GROUND_Y - player.size / 2;
  player.velY = 0;
  player.rotation = 0;
  player.onGround = true;
  player.isDead = false;

  attempts++;
  scene = "playing";
}

function goMenu() {
  scene = "menu";
  menuPanel.style.display = "flex";
  completeUI.style.display = "none";
  editorHelp.style.display = "none";
  baseSpeed = 6;
}

/* =========================================================
   COLLISION & TRIGGERS
========================================================= */
function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function hitSpike() {
  const px = player.x - player.size / 2;
  const py = player.y - player.size / 2;

  for (const ob of currentObjects) {
    if (ob.type !== "spike") continue;
    const sx = ob.x - cameraX;
    const baseY = gravityDir === 1 ? GROUND_Y : CEIL_Y;

    const sw = ob.w * 0.7;
    const sh = ob.h * 0.8;
    const sxAdj = sx + (ob.w - sw) / 2;
    const syAdj = gravityDir === 1 ? baseY - sh : baseY;

    if (rectCollide(px, py, player.size, player.size, sxAdj, syAdj, sw, sh)) {
      return true;
    }
  }
  return false;
}

function triggerObjects() {
  const worldX = cameraX + player.x;
  for (const ob of currentObjects) {
    if (ob.triggered) continue;
    if (Math.abs(worldX - ob.x) < 30) {
      if (ob.type === "pad") {
        player.velY = -gravityDir * 16;
        player.onGround = false;
        ob.triggered = true;
      } else if (ob.type === "gravityPortal") {
        gravityDir *= -1;
        player.rotation += Math.PI;
        ob.triggered = true;
      } else if (ob.type === "speedPortal") {
        currentSpeedMult = ob.speedMult || 1;
        ob.triggered = true;
      }
    }
  }
}

/* =========================================================
   FINISH PORTAL + SOUND
========================================================= */
const finishSound = new Audio(
  "data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Yc0AAAAA////AP//AAD//wAA//8AAP//AAD//wAA"
);

function reachedFinish() {
  const portalScreenX = finishPortalX - cameraX;
  return portalScreenX < player.x + player.size / 2;
}

/* =========================================================
   DRAWING
========================================================= */
function drawBackground() {
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "#1a68ff");
  g.addColorStop(1, "#021633");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
}

function drawGround() {
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  ctx.fillStyle = "#003366";
  if (gravityDir === 1) ctx.fillRect(0, gy, W, H - gy);
  else ctx.fillRect(0, 0, W, gy);

  const size = 50;
  let off = -(cameraX % size);
  for (let x = off - size; x < W + size; x += size) {
    ctx.fillStyle = "#004c99";
    const top = gravityDir === 1 ? gy - 22 : gy - 2;
    ctx.fillRect(x + 4, top, size - 8, 24 * gravityDir);
  }
}

function drawSpike(ob) {
  const screenX = ob.x - cameraX;
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;

  ctx.save();
  ctx.fillStyle = "#ff0055";
  ctx.strokeStyle = "#ffb3d1";
  ctx.lineWidth = 2;

  ctx.beginPath();
  if (gravityDir === 1) {
    ctx.moveTo(screenX, gy);
    ctx.lineTo(screenX + ob.w / 2, gy - ob.h);
    ctx.lineTo(screenX + ob.w, gy);
  } else {
    ctx.moveTo(screenX, gy);
    ctx.lineTo(screenX + ob.w / 2, gy + ob.h);
    ctx.lineTo(screenX + ob.w, gy);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawPad(ob) {
  const screenX = ob.x - cameraX;
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  const y = gravityDir === 1 ? gy - ob.h : gy;

  ctx.save();
  ctx.fillStyle = "#ffd800";
  ctx.strokeStyle = "#b38f00";
  ctx.lineWidth = 2;
  ctx.fillRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.strokeRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.restore();
}

function drawGravityPortal(ob) {
  const screenX = ob.x - cameraX;
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  const y = gy - ob.h * (gravityDir === 1 ? 1 : 0);

  ctx.save();
  ctx.fillStyle = "rgba(0,255,204,0.25)";
  ctx.strokeStyle = "#00ffcc";
  ctx.lineWidth = 3;
  ctx.fillRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.strokeRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.restore();
}

function drawSpeedPortal(ob) {
  const screenX = ob.x - cameraX;
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  const y = gy - ob.h * (gravityDir === 1 ? 1 : 0);

  ctx.save();
  ctx.fillStyle = "rgba(255,136,0,0.3)";
  ctx.strokeStyle = "#ff8800";
  ctx.lineWidth = 3;
  ctx.fillRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.strokeRect(screenX - ob.w / 2, y, ob.w, ob.h * gravityDir);
  ctx.font = "12px system-ui";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.fillText((ob.speedMult || 1) + "x", screenX, y + (ob.h / 2) * gravityDir);
  ctx.restore();
}

/* Neon finish portal */
function drawFinishPortal() {
  const screenX = finishPortalX - cameraX;
  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  const w = 50, h = 130;
  const y = gy - (gravityDir === 1 ? h : 0);

  ctx.save();
  ctx.lineWidth = 6;
  ctx.strokeStyle = "#00ff66";
  ctx.shadowColor = "#00ff66";
  ctx.shadowBlur = 16;
  ctx.strokeRect(screenX - w / 2, y, w, h * gravityDir);

  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = "#00ff66";
  for (let i = -12; i <= 12; i += 6) {
    ctx.fillRect(screenX + i - 2, y + 6, 4, h - 12);
  }
  ctx.restore();
}

function drawPlayer() {
  const s = player.size;
  const half = s / 2;

  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.rotate(player.rotation);

  ctx.fillStyle = "#ffd800";
  ctx.fillRect(-half, -half, s, s);

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.strokeRect(-half, -half, s, s);

  ctx.fillStyle = "#000";
  ctx.fillRect(-half + 10, -half + 10, 8, 8);
  ctx.fillRect(half - 18, -half + 10, 8, 8);

  ctx.restore();
}

function drawObjects() {
  for (const ob of currentObjects) {
    const screenX = ob.x - cameraX;
    if (screenX < -200 || screenX > W + 200) continue;

    if (ob.type === "spike") drawSpike(ob);
    else if (ob.type === "pad") drawPad(ob);
    else if (ob.type === "gravityPortal") drawGravityPortal(ob);
    else if (ob.type === "speedPortal") drawSpeedPortal(ob);
  }
}

function drawEditor() {
  // simple blue background
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "#14386f");
  g.addColorStop(1, "#020b1a");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  const gy = GROUND_Y;
  ctx.fillStyle = "#002b55";
  ctx.fillRect(0, gy, W, H - gy);

  // grid
  const gs = editor.grid;
  const offset = -(editor.camX % gs);
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  for (let x = offset; x < W; x += gs) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  ctx.restore();

  // objects
  for (const ob of editor.objects) {
    const screenX = ob.x - editor.camX;
    if (screenX < -100 || screenX > W + 100) continue;

    if (ob.type === "spike") {
      ctx.save();
      ctx.fillStyle = "#ff0055";
      ctx.strokeStyle = "#ffb3d1";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screenX, gy);
      ctx.lineTo(screenX + ob.w / 2, gy - ob.h);
      ctx.lineTo(screenX + ob.w, gy);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    } else if (ob.type === "pad") {
      ctx.save();
      ctx.fillStyle = "#ffd800";
      ctx.strokeStyle = "#b38f00";
      ctx.lineWidth = 2;
      ctx.fillRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.strokeRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.restore();
    } else if (ob.type === "gravityPortal") {
      ctx.save();
      ctx.fillStyle = "rgba(0,255,204,0.25)";
      ctx.strokeStyle = "#00ffcc";
      ctx.lineWidth = 3;
      ctx.fillRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.strokeRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.restore();
    } else if (ob.type === "speedPortal") {
      ctx.save();
      ctx.fillStyle = "rgba(255,136,0,0.3)";
      ctx.strokeStyle = "#ff8800";
      ctx.lineWidth = 3;
      ctx.fillRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.strokeRect(screenX - ob.w / 2, gy - ob.h, ob.w, ob.h);
      ctx.font = "12px system-ui";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText((ob.speedMult || 1) + "x", screenX, gy - ob.h / 2);
      ctx.restore();
    }
  }

  // editor status
  ctx.fillStyle = "white";
  ctx.font = "13px system-ui";
  ctx.fillText(
    `EDITOR | Objects: ${editor.objects.length} | Selected: ${editor.selectedType}`,
    10, 18
  );
}

/* =========================================================
   GAME LOOP
========================================================= */
function snapRotation() {
  const q = Math.PI / 2;
  player.rotation = Math.round(player.rotation / q) * q;
}

function die() {
  player.isDead = true;
  scene = "dead";
  setTimeout(() => {
    if (isCustomLevel) startCustomLevel();
    else startLevel(currentLevel);
  }, 500);
}

function levelComplete() {
  if (completeShown) return;
  completeShown = true;
  scene = "complete";
  baseSpeed = 0;
  currentSpeedMult = 0;
  player.velY = 0;
  finishSound.play();
  setTimeout(() => {
    completeUI.style.display = "flex";
  }, 250);
}

function update() {
  if (scene === "menu") {
    drawBackground();
    drawGround();
    drawObjects();
    drawFinishPortal();
    drawPlayer();
    requestAnimationFrame(update);
    return;
  }

  if (scene === "editor") {
    drawEditor();
    requestAnimationFrame(update);
    return;
  }

  if (scene === "dead" || scene === "complete") {
    drawBackground();
    drawGround();
    drawObjects();
    drawFinishPortal();
    drawPlayer();
    requestAnimationFrame(update);
    return;
  }

  // playing
  cameraX += baseSpeed * currentSpeedMult;

  if (jumpQueued && player.onGround) {
    player.velY = -gravityDir * 13;
    player.onGround = false;
  }
  jumpQueued = false;

  player.velY += gravityVal * gravityDir;
  player.y += player.velY;

  const gy = gravityDir === 1 ? GROUND_Y : CEIL_Y;
  const half = player.size / 2;

  if (gravityDir === 1) {
    if (player.y + half >= gy) {
      player.y = gy - half;
      player.velY = 0;
      if (!player.onGround) snapRotation();
      player.onGround = true;
    } else {
      player.onGround = false;
    }
  } else {
    if (player.y - half <= gy) {
      player.y = gy + half;
      player.velY = 0;
      if (!player.onGround) snapRotation();
      player.onGround = true;
    } else {
      player.onGround = false;
    }
  }

  if (!player.onGround) {
    player.rotation += 0.22 * gravityDir;
  }

  triggerObjects();

  if (hitSpike()) {
    die();
  } else if (reachedFinish()) {
    levelComplete();
  }

  drawBackground();
  drawGround();
  drawObjects();
  drawFinishPortal();
  drawPlayer();

  requestAnimationFrame(update);
}

/* =========================================================
   START
========================================================= */
drawBackground();
drawGround();
drawObjects();
drawFinishPortal();
drawPlayer();
requestAnimationFrame(update);
</script>
</body>
</html>
